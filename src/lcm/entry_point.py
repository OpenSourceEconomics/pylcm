from __future__ import annotations

from collections.abc import Callable
from functools import partial
from typing import TYPE_CHECKING, Literal

import jax
import pandas as pd
from jax import Array

from lcm.input_processing import process_model
from lcm.interfaces import StateActionSpace, StateSpaceInfo, Target
from lcm.logging import get_logger
from lcm.max_Q_over_a import get_argmax_and_max_Q_over_a, get_max_Q_over_a
from lcm.next_state import get_next_state_function
from lcm.Q_and_F import (
    get_Q_and_F,
)
from lcm.simulation.simulate import simulate
from lcm.solution.solve_brute import solve
from lcm.state_action_space import (
    create_state_action_space,
    create_state_space_info,
)
from lcm.typing import ArgmaxQOverAFunction, ParamsDict

if TYPE_CHECKING:
    from collections.abc import Callable

    import pandas as pd

    from lcm.typing import (
        ArgmaxQOverAFunction,
        MaxQOverAFunction,
        ParamsDict,
    )
    from lcm.user_model import Model


def get_lcm_function(
    model: Model,
    *,
    targets: Literal["solve", "simulate", "solve_and_simulate"],
    debug_mode: bool = True,
    jit: bool = True,
) -> tuple[Callable[..., dict[int, Array] | pd.DataFrame], ParamsDict]:
    """Entry point for users to get high level functions generated by lcm.

    Return the function to solve and/or simulate a model along with a template for the
    parameters.

    Advanced users might want to use lower level functions instead, but can read the
    source code of this function to see how the lower level components are meant to be
    used.

    Args:
        model: User model specification.
        targets: The requested function types. Currently only "solve", "simulate" and
            "solve_and_simulate" are supported.
        debug_mode: Whether to log debug messages.
        jit: Whether to jit the internal functions.

    Returns:
        - A function that can be used to solve and/or simulate the model (see below).
        - A dictionary with the parameters that the function expects.

        For targets = "solve":
        ----------------------
        A function that takes params and returns the solution of the model, that is, a
        dictionary mapping model period to the respective value function array.

        For targets = "simulate":
        -------------------------
        A function that takes params, a dictionary of initial states, and a model
        solution in form of a value function array, and returns the simulated
        trajectories in a pandas DataFrame, where the multi-index is the combination of
        period and initial-state-ID, and the columns are the optimal actions.

        For targets = "solve_and_simulate":
        -----------------------------------
        The same as targets = "simulate", but with the solution step partialled in, such
        that the function does not require the solution as an argument.

    """
    # ==================================================================================
    # preparations
    # ==================================================================================
    if targets not in {"solve", "simulate", "solve_and_simulate"}:
        raise NotImplementedError

    internal_model = process_model(model)
    last_period = internal_model.n_periods - 1

    logger = get_logger(debug_mode=debug_mode)

    # ==================================================================================
    # Create model functions and state-action-spaces
    # ==================================================================================
    state_action_spaces: dict[int, StateActionSpace] = {}
    state_space_infos: dict[int, StateSpaceInfo] = {}
    max_Q_over_a_functions: dict[int, MaxQOverAFunction] = {}
    argmax_and_max_Q_over_a_functions: dict[int, ArgmaxQOverAFunction] = {}

    for period in reversed(range(internal_model.n_periods)):
        is_last_period = period == last_period

        state_action_space = create_state_action_space(
            model=internal_model,
            is_last_period=is_last_period,
        )

        state_space_info = create_state_space_info(
            model=internal_model,
            is_last_period=is_last_period,
        )

        if is_last_period:
            next_state_space_info = LastPeriodsNextStateSpaceInfo
        else:
            next_state_space_info = state_space_infos[period + 1]

        Q_and_F = get_Q_and_F(
            model=internal_model,
            next_state_space_info=next_state_space_info,
            period=period,
        )

        max_Q_over_a = get_max_Q_over_a(
            Q_and_F=Q_and_F,
            actions_names=tuple(state_action_space.continuous_actions)
            + tuple(state_action_space.discrete_actions),
            states_names=tuple(state_action_space.states),
        )

        argmax_and_max_Q_over_a = get_argmax_and_max_Q_over_a(
            Q_and_F=Q_and_F,
            actions_names=tuple(state_action_space.discrete_actions)
            + tuple(state_action_space.continuous_actions),
        )

        state_action_spaces[period] = state_action_space
        state_space_infos[period] = state_space_info
        max_Q_over_a_functions[period] = jax.jit(max_Q_over_a) if jit else max_Q_over_a
        argmax_and_max_Q_over_a_functions[period] = (
            jax.jit(argmax_and_max_Q_over_a) if jit else argmax_and_max_Q_over_a
        )

    # ==================================================================================
    # select requested solver and partial arguments into it
    # ==================================================================================
    solve_model = partial(
        solve,
        state_action_spaces=state_action_spaces,
        max_Q_over_a_functions=max_Q_over_a_functions,
        logger=logger,
    )

    _next_state_simulate = get_next_state_function(
        model=internal_model, target=Target.SIMULATE
    )
    next_state_simulate = jax.jit(_next_state_simulate) if jit else _next_state_simulate
    simulate_model = partial(
        simulate,
        argmax_and_max_Q_over_a_functions=argmax_and_max_Q_over_a_functions,
        model=internal_model,
        next_state=next_state_simulate,
        logger=logger,
    )

    def solve_and_simulate_model(
        params: ParamsDict,
        initial_states: dict[str, Array],
        *,
        additional_targets: list[str] | None = None,
        seed: int | None = None,
    ) -> pd.DataFrame:
        """First solve the model and then simulate the model forward in time."""
        V_arr_dict = solve_model(params)
        return simulate_model(
            params=params,
            initial_states=initial_states,
            V_arr_dict=V_arr_dict,
            additional_targets=additional_targets,
            seed=seed,
        )

    # Repeat the target function signature to satisfy type checkers.
    target_func: Callable[..., dict[int, Array] | pd.DataFrame]

    if targets == "solve":
        target_func = solve_model
    elif targets == "simulate":
        target_func = simulate_model
    elif targets == "solve_and_simulate":
        target_func = solve_and_simulate_model

    return target_func, internal_model.params


LastPeriodsNextStateSpaceInfo = StateSpaceInfo(
    states_names=(),
    discrete_states={},
    continuous_states={},
)
